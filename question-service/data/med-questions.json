[
    {
        "QuestionTitle":"Rotting Oranges",
        "QuestionBody":"You are given an m x n grid where each cell can have one of three values:\n\n* 0 representing an empty cell,\n* 1 representing a fresh orange, or\n* 2 representing a rotten orange.\n\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n\nExamples:\n\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\n\nInput: grid = [[0,2]]\nOutput: 0\n\nConstraints:\n\n* m == grid.length\n* n == grid[i].length\n* 1 <= m, n <= 10\n* grid[i][j] is 0, 1, or 2.",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"Maximum Subarray",
        "QuestionBody":"Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\nA subarray is a contiguous part of an array.\n\nExamples:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\n\nInput: nums = [1]\nOutput: 1\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\n\nConstraints:\n* 1 <= nums.length <= 10^5\n* -10^4 <= nums[i] <= 10^4",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"01 Matrix",
        "QuestionBody":"Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\n\nThe distance between two adjacent cells is 1.\n\nExamples:\n\nInput: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]\n\nInput: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]\n\nConstraints:\n* m == mat.length\n* n == mat[i].length\n* 1 <= m, n <= 10^4\n* 1 <= m * n <= 10^4\n* mat[i][j] is either 0 or 1.\n* There is at least one 0 in mat.",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"Insert Intervals",
        "QuestionBody":"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn intervals after the insertion.\n\nExamples:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\n\nConstraints:\n* 0 <= intervals.length <= 10^4\n* intervals[i].length == 2\n* 0 <= starti <= endi <= 10^5\n* intervals is sorted by starti in ascending order.\n* newInterval.length == 2\n* 0 <= start <= end <= 10^5",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"K Closest Points to Origin",
        "QuestionBody":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\n\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)^2 + (y1 - y2)^2).\n\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n\nExamples:\n\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\n\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\n\nConstraints:\n* 1 <= k <= points.length <= 10^4\n* -10^4 < xi, yi < 10^4",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"Longest Substring Without Repeating Characters",
        "QuestionBody":"Given a string s, find the length of the longest substring without repeating characters.\n\nExamples:\n\nInput: s = \"abcabcbb\"\nOutput: 3\n\nInput: s = \"bbbbb\"\nOutput: 1\n\nInput: s = \"pwwkew\"\nOutput: 3\n\nConstraints:\n* 0 <= s.length <= 5 * 10^4\n* s consists of English letters, digits, symbols and spaces.",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"3Sum",
        "QuestionBody":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExamples:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\n\nInput: nums = [0,1,1]\nOutput: []\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\n\nConstraints:\n* 3 <= nums.length <= 3000\n* -10^5 <= nums[i] <= 10^5",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"Course Schedule",
        "QuestionBody":"There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\n* For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\nExamples:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\n\nConstraints:\n* 1 <= numCourses <= 2000\n* 0 <= prerequisites.length <= 5000\n* prerequisites[i].length == 2\n* 0 <= ai, bi < numCourses\n* All the pairs prerequisites[i] are unique.",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"Coin Change",
        "QuestionBody":"You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nExamples:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\n\nInput: coins = [2], amount = 3\nOutput: -1\n\nInput: coins = [1], amount = 0\nOutput: 0\n\nConstraints:\n* 1 <= coins.length <= 12\n* 1 <= coins[i] <= 2^31 - 1\n* 0 <= amount <= 104",
        "QuestionDifficulty":"medium"
    },
    {
        "QuestionTitle":"Implement Trie (Prefix Tree)",
        "QuestionBody":"A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n* Trie() Initializes the trie object.\n* void insert(String word) Inserts the string word into the trie.\n* boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\n* boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nExamples:\n\nInput:\nOrder of Operation: [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\nInput for each operation: [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n\nOutput:\nOutput for each operation: [null, null, true, false, true, null, true]\n\nConstraints:\n* 1 <= word.length, prefix.length <= 2000\n* word and prefix consist only of lowercase English letters.\n* At most 3 * 104 calls in total will be made to insert, search, and startsWith.",
        "QuestionDifficulty":"medium"
    }
]