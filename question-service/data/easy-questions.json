[
    {
        "QuestionTitle":"Two Sum",
        "QuestionBody":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nExamples:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\nConstraints:\n* 2 <= nums.length <= 10^4\n* -109 <= nums[i] <= 10^9\n* -10^9 <= target <= 10^9\nOnly one valid answer exists.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Valid Parentheses",
        "QuestionBody":"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nExamples:\n\nInput: s = \"()\"\nOutput: true\n\nInput: s = \"()[]{}\"\nOutput: true\n\nInput: s = \"(]\"\nOutput: false\n\nConstraints:\n* 1 <= s.length <= 10^4\n* s consists of parentheses only '()[]{}'.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Merge Two Sorted Lists",
        "QuestionBody":"You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\nExamples:\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nInput: list1 = [], list2 = []\nOutput: []\n\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\nConstraints:\n* The number of nodes in both lists is in the range [0, 50].\n* -100 <= Node.val <= 100\n* Both list1 and list2 are sorted in non-decreasing order.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Best Time to Buy and Sell Stock",
        "QuestionBody":"You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExamples:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\n\nConstraints:\n* 1 <= prices.length <= 10^5\n* 0 <= prices[i] <= 10^4",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Balanced Binary Tree",
        "QuestionBody":"Given a binary tree, determine if it is height-balanced.\n\nFor this problem, a height-balanced binary tree is defined as:\n* a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n\nExamples:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\nInput: root = []\nOutput: true\n\nConstraints:\n* The number of nodes in the tree is in the range [0, 5000].\n* -10^4 <= Node.val <= 10^4",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Implement Queue using Stacks",
        "QuestionBody":"Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\n\nImplement the MyQueue class:\n\n* void push(int x) Pushes element x to the back of the queue.\n* int pop() Removes the element from the front of the queue and returns it.\n* int peek() Returns the element at the front of the queue.\n* boolean empty() Returns true if the queue is empty, false otherwise.\n\nNotes:\n\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\nDepending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\nExamples:\n\nInput\nOrder of operations: [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\nInput for each operation: [[], [1], [2], [], [], []]\n\nOutput\nOutput for each operation: [null, null, null, 1, 1, false]\n\nConstraints:\n* 1 <= x <= 9\n* At most 100 calls will be made to push, pop, peek, and empty.\n* All the calls to pop and peek are valid.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Ransom Note",
        "QuestionBody":"Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\n\nEach letter in magazine can only be used once in ransomNote.\n\nExamples:\n\nInput: ransomNote = \"a\", magazine = \"b\"\nOutput: false\n\nInput: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false\n\nInput: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true\n\nConstraints:\n* 1 <= ransomNote.length, magazine.length <= 10^5\n* ransomNote and magazine consist of lowercase English letters.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Add Binary",
        "QuestionBody":"Given two binary strings a and b, return their sum as a binary string.\n\nExamples:\n\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n\nConstraints:\n* 1 <= a.length, b.length <= 10^4\n* a and b consist only of '0' or '1' characters.\n* Each string does not contain leading zeros except for the zero itself.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Reverse Linked List",
        "QuestionBody":"Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nExamples:\n\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\nInput: head = [1,2]\nOutput: [2,1]\n\nInput: head = []\nOutput: []\n\nConstraints:\n* The number of nodes in the list is the range [0, 5000].\n* -5000 <= Node.val <= 5000",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Contains Duplicate",
        "QuestionBody":"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\nExamples:\n\nInput: nums = [1,2,3,1]\nOutput: true\n\nInput: nums = [1,2,3,4]\nOutput: false\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n\nConstraints:\n* 1 <= nums.length <= 10^5\n* -10^9 <= nums[i] <= 10^9",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Majority Element",
        "QuestionBody":"Given an array nums of size n, return the majority element.\n\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\n\nExamples:\n\nInput: nums = [3,2,3]\nOutput: 3\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\nConstraints:\n* n == nums.length\n* 1 <= n <= 5 * 104\n* -109 <= nums[i] <= 109",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Valid Anagram",
        "QuestionBody":"Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExamples:\n\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nConstraints:\n* 1 <= s.length, t.length <= 5 * 10^4\n* s and t consist of lowercase English letters.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Climbing Stairs",
        "QuestionBody":"You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nExamples:\n\nInput: n = 2\nOutput: 2\n\nInput: n = 3\nOutput: 3\n\nConstraints:\n* 1 <= n <= 45",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Longest Palindrome",
        "QuestionBody":"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\n\nLetters are case sensitive, for example, \"Aa\" is not considered a palindrome here.\n\nExamples:\n\nInput: s = \"abccccdd\"\nOutput: 7\n\nInput: s = \"a\"\nOutput: 1\n\nConstraints:\n* 1 <= s.length <= 2000\n* s consists of lowercase and/or uppercase English letters only.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Backspace String Compare",
        "QuestionBody":"Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.\n\nExamples:\n\nInput: s = \"ab#c\", t = \"ad#c\"\nOutput: true\n\nInput: s = \"ab##\", t = \"c#d#\"\nOutput: true\n\nInput: s = \"a#c\", t = \"b\"\nOutput: false\n\nConstraints:\n* 1 <= s.length, t.length <= 200\n* s and t only contain lowercase letters and '#' characters.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Binary Search",
        "QuestionBody":"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExamples:\n\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\n\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\n\nConstraints:\n* 1 <= nums.length <= 10^4\n* -10^4 < nums[i], target < 10^4\n* All the integers in nums are unique.\n* nums is sorted in ascending order.",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Pascal Triangle",
        "QuestionBody":"Given an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n\nExamples:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nInput: numRows = 1\nOutput: [[1]]\n\nConstraints:\n* 1 <= numRows <= 30",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Happy Number",
        "QuestionBody":"Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the following process:\n\n* Starting with any positive integer, replace the number by the sum of the squares of its digits.\n* Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n* Those numbers for which this process ends in 1 are happy.\n\nReturn true if n is a happy number, and false if not.\n\nExamples:\n\nInput: n = 19\nOutput: true\n\nInput: n = 2\nOutput: false\n\nConstraints:\n* 1 <= n <= 2^31 - 1",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Nim Game",
        "QuestionBody":"You are playing the following Nim Game with your friend:\n\n* Initially, there is a heap of stones on the table.\n* You and your friend will alternate taking turns, and you go first.\n* On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n* The one who removes the last stone is the winner.\n\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.\n\nExamples:\n\nInput: n = 4\nOutput: false\n\nInput: n = 1\nOutput: true\n\nInput: n = 2\nOutput: true\n\nConstraints:\n* 1 <= n <= 2^31 - 1",
        "QuestionDifficulty":"easy"
    },
    {
        "QuestionTitle":"Intersection of Two Arrays",
        "QuestionBody":"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\n\nExamples:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4] OR [4,9]\n\nConstraints:\n* 1 <= nums1.length, nums2.length <= 1000\n* 0 <= nums1[i], nums2[i] <= 1000",
        "QuestionDifficulty":"easy"
    }
]
